# 210503_最大矩形

直方图是由在公共基线处对齐的一系列矩形组成的多边形。
矩形具有相等的宽度，但可以具有不同的高度。
例如，图例左侧显示了由高度为 2,1,4,5,1,3,32,1,4,5,1,3,3 的矩形组成的直方图，矩形的宽度都为 11：
![avatar](/210503zudajuxing.png)
通常，直方图用于表示离散分布，例如，文本中字符的频率。
现在，请你计算在公共基线处对齐的直方图中最大矩形的面积。
图例右图显示了所描绘直方图的最大对齐矩形。

## 输入格式

输入包含几个测试用例。
每个测试用例占据一行，用以描述一个直方图，并以整数 nn 开始，表示组成直方图的矩形数目。
然后跟随 nn 个整数 h1，…，hnh1，…，hn。
这些数字以从左到右的顺序表示直方图的各个矩形的高度。
每个矩形的宽度为 11。
同行数字用空格隔开。
当输入用例为 n=0n=0 时，结束输入，且该用例不用考虑。

## 输出格式
对于每一个测试用例，输出一个整数，代表指定直方图中最大矩形的区域面积。
每个数据占一行。
请注意，此矩形必须在公共基线处对齐。
### 数据范围
1≤n≤1000001≤n≤100000,
0≤hi≤10000000000≤hi≤1000000000
### 输入样例：
7 2 1 4 5 1 3 3
4 1000 1000 1000 1000
0
### 输出样例：
8
4000
题目分析
两种解题思路，当n为1000时，可以采用n2复杂度的解题思路，
当n为上题要求的1000000时，用单调栈logn复杂度的解法。

解法一：n2复杂度



## 代码解析

```C++
//
//  210503_zuidajuxing.cpp
//  ceshi
//
//  Created by kakawu on 2021/5/3.
//

//#include <stdio.h>
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N=10010;

int n;
int h[N];

int main(){
    
    cin>>n;
    for (int i=1;i<n;i++)cin>>h[i];

    int res=0;
    for (int i =1;i<n;i++){
        int l=i,r=i;
        while (l>=1 && h[l]>=h[i]) l--;
//        h[i]代表当前的长条，从当前往左，获取h[l]的编号，即往左多少个长条高于或等于当前长条h[i]
        while (r<=n && h[r]>=h[i])r++;
//      同理可得右边的长条
        res=max(res,h[i]*(r-l-1));
//        例如 图示里的，当遍历第五个长条时。while结束时l和r左右分别为2，7，所以宽度是7-2-1，答案为4
    }
    cout<<res<<endl;
    return 0;
    
}
    

/*
测试数据
输入：
6
3 1 6 5 2 3
输出：
10
*/

```